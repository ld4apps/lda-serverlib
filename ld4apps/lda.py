"""
This module provides resource management helper functions for lda server implementations.

Before importing this module, several environment variables must first be set to configure the database for storing resources.
The default storage implementation uses MongoDB, but this can be changed by setting the OPERATION_PRIMITIVES environment
variable to the name of a different module.

When using the default MongoDB implementation, 3 additional environment variables must be set:
    
1. MONGODB_DB_HOST - hostname of the MONGODB server to use
2. MONGODB_DB_POST - the MONGDOB server port
3. APP_NAME - the name of you application, which is used as the DB name where the resources will be stored

Example Usage:
    import os
    os.environ['MONGODB_DB_HOST'] = 'localhost'
    os.environ['MONGODB_DB_PORT'] = '27017'
    os.environ['APP_NAME'] = 'teststore'

    from ld4apps import lda
    foo_container_environ = {'HTTP_HOST': 'localhost', 'PATH_INFO': '/tst/foo', 'QUERY_STRING': ''}
    new_foo_resource = {'rdfs_label': 'my foo', 'rdf_type': 'http://example.org#Foo'}
    body, status, headers = lda.create_document(foo_container_environ, new_foo_resource, 'in_foo_container')
    ...
"""
import os
import json
import Cookie, jwt
from webob import Request

if 'URL_POLICY_CLASS' not in os.environ:
    os.environ['URL_POLICY_CLASS'] = 'ld4apps.url_policy#TypeQualifiedHostnameTenantURLPolicy'
if 'CHECK_ACCESS_RIGHTS' not in os.environ:
    os.environ['CHECK_ACCESS_RIGHTS'] = 'False'
    
import rdf_json
import example_logic_tier as base
from rdfgraphlib import rdfjson_to_graph, serialize_graph
from storage import operation_primitives
from base_constants import RDF, LDP

def create_document(environ, document, membership_property, complete_document_callback=None):
    """
    Create and store a new lD resource and link it to the LD container resource with the REQUEST_URI of the specified WSGI ``environ``, 
    usually the target of an HTTP POST request. The new resource is initialized with the fields in ``document``,
    an applicaion/json formatted dictionary, and then linked to the container resource using a back-pointer field specified by 
    ``membership_property``. The ``membership_property`` must match the membership property associated with the specified
    LD Container. An LD container is a virtual resource whose contents is generated by querying the database for resources that
    reference it. See ``get_virtual_container`` for more details. 
    
    The return value is a triple of (body, status, headers). The values of headers and body depends on the status:
      201 - Created           => Success. headers is a list of headers to return to the client. It will contain at least a location entry with 
                                 the URL of the newly-created resource. The body is a dictionary that contains the application/json representation
                                 of the created object.
      others                  => headers may be an empty list or may include headers to return to the client.
                                 The body is a list of pairs, where the first element of the pair identifies the field in error, or is ''.
                                 The second element of the pair will start with a number, a space, and an optional string explaining the error.

    :param environ: a WSGI environment identifying the LD container for the new resource
    :param document: an application/json structure to initialize the new document
    :param membership_property: property name used to link the new resource to its container 
    :param complete_document_callback: (optional)A callback function that will be invoked before returning the response document
    """
    domain_logic = Domain_Logic(environ, complete_document_callback)
    container_url = domain_logic.document_url()
    document = dict(document) # make a copy before updating!
    document[membership_property] = container_url
    document = domain_logic.convert_compact_json_to_rdf_json(document)
    status, headers, body = domain_logic.create_document(document, domain_logic.document_id + '/')
    if not hasattr(body, 'graph_url'): # not an rdf_json document - probably an error condition
        body = json.dumps(body, cls=rdf_json.RDF_JSON_Encoder)
    else:
        body = domain_logic.convert_rdf_json_to_compact_json(body)
    return body, status, headers

def get_document(environ, complete_document_callback=None):
    """
    Get the lD resource with the REQUEST_URI of the specified WSGI ``environ``, usually the target of an HTTP GET request. 
    
    The return value is a triple of (body, status, headers). The values of headers and body depends on the status:
      200 - OK                => Success. headers is a list of headers to return to the client. 
                                 The body is a dictionary that contains the application/json representation of the resource.
      others                  => headers may be an empty list or may include headers to return to the client.
                                 The body is a list of pairs, where the first element of the pair identifies the field in error, or is ''.
                                 The second element of the pair will start with a number, a space, and an optional string explaining the error.

    :param environ: a WSGI environment identifying the LD resource to get
    :param complete_document_callback: (optional) A callback function that will be invoked before returning the response document
    """
    domain_logic = Domain_Logic(environ, complete_document_callback)
    status, headers, body = domain_logic.get_document()
    add_standard_headers(environ, headers)
    if not hasattr(body, 'graph_url'): # not an rdf_json document - probably an error condition
        body = json.dumps(body, cls=rdf_json.RDF_JSON_Encoder)
    else:
        body = domain_logic.convert_rdf_json_to_compact_json(body)
    return body, status, headers

def patch_document(environ, document, complete_document_callback=None):
    """
    Patch the contents of ``document`` into the lD resource with the REQUEST_URI of the specified WSGI ``environ``, usually the target of
    an HTTP PATCH request. The ``document`` argument, an applicaion/json formatted dictionary, contains the subset of the resource's fields
    that are to be changed. A field value of None (null), indicates that the field should be removed from the resource.
    
    The specified ``environ`` must also include a CE-Revision header, the value of which must match the resource's current ce_revision property.
    This is usually the value that was last read by the client in a GET of the resource. If the ce_revision property in the database does
    not match the value provided by the client, the patch will fail and an HTTP 409 (Conflict) status code will be returned. 
    If the update succeeds, the ce_revision in the database will be updated, along with the specidied fields, and an HTTP 200 (OK) status
    code will be returned. A history document will also be created to capture the previous state of the resource.

    The return value is a triple of (body, status, headers). The values of headers and body depends on the status:
      200 - OK                => Successful patch. headers is a list of headers to return to the client. 
                                 The body is a dictionary that contains the application/json representation of the updated resource.
      others                  => headers may be an empty list or may include headers to return to the client.
                                 The body is a list of pairs, where the first element of the pair identifies the field in error, or is ''.
                                 The second element of the pair will start with a number, a space, and an optional string explaining the error.

    :param environ: a WSGI environment identifying the LD resource to update and its expected revision (CE-Revision header) 
    :param document: an application/json structure containing the resource's fields to change
    :param complete_document_callback: (optional)A callback function that will be invoked before returning the response document
    """
    domain_logic = Domain_Logic(environ, complete_document_callback)
    document = domain_logic.convert_compact_json_to_rdf_json(document)
    status, headers, body = domain_logic.patch_document(document)
    if not hasattr(body, 'graph_url'): # not an rdf_json document - probably an error condition
        body = json.dumps(body, cls=rdf_json.RDF_JSON_Encoder)
    else:
        body = domain_logic.convert_rdf_json_to_compact_json(body)
    return body, status, headers

def delete_document(environ):
    """
    Delete the lD resource with the REQUEST_URI of the specified WSGI ``environ``, usually the target of an HTTP DELETE request. 

    The return value is a triple of (body, status, headers). The values of headers and body depends on the status:
      204 - No content        => Successful delete. headers is a list of headers to return to the client. body is an empty list.
      others                  => headers may be an empty list or may include headers to return to the client.
                                 The body is a list of pairs, where the first element of the pair identifies the field in error, or is ''.
                                 The second element of the pair will start with a number, a space, and an optional string explaining the error.

    :param environ: a WSGI environment identifying the LD resource to delete
    """
    domain_logic = Domain_Logic(environ)
    status, headers, body = domain_logic.delete_document()
    add_standard_headers(environ, headers)
    return body, status, headers

def get_virtual_container(environ, membership_property, complete_document_callback=None):
    """
    Get the LD container resource with the REQUEST_URI of the specified WSGI ``environ``, usually the target of an HTTP GET request.
    LD container resources are virtual resources. They are not stored in the database, but rather their contents is generated by
    querying the database for resources that reference the container.
    
    The URL of a container is of the form /<query-space>/<container-type> (e.g., "/tst/foo"). The representation of a container
    is an ldp:DirectContainer as defined in the W3C Linked Data Platform 1.0 specification (http://www.w3.org/TR/2015/REC-ldp-20150226/).
    
    TODO: more details
    
    :param environ: a WSGI environment identifying the LD container resource
    :param membership_property: property name used to query for resources in the container 
    :param complete_document_callback: (optional)A callback function that will be invoked for each resource in the container
    """
    domain_logic = Domain_Logic(environ, complete_document_callback)
    container_url = domain_logic.document_url()
    converter = rdf_json.Compact_json_to_rdf_json_converter(domain_logic.namespace_mappings())
    membership_predicate = converter.expand_predicate(membership_property)
    body = domain_logic.create_container(container_url, container_url, membership_predicate) 
    status, body = domain_logic.complete_request_document(body)
    if not hasattr(body, 'graph_url'): # not an rdf_json document - probably an error condition
        body = json.dumps(body, cls=rdf_json.RDF_JSON_Encoder)
    else:
        body = domain_logic.convert_rdf_json_to_compact_json(body)
    return body, status, []

def execute_query(environ, query, complete_document_callback=None):
    """
    Execute the specified ``query`` against the collection identified REQUEST_URI of the specified WSGI ``environ``.
    This function returns an ldp:Container with 0 or more matching documents. The ``query`` argument is a Python dictionary,
    the format of which is TBD.

    Queries are safe and idempotent. That is, they do not have side-effects, and (weaker and implied by safe) the result of doing them
    muultiple times is the same as doing them once. In that sense, they are similar to a GET, but done via POST.

    The return value is a triple of (body, status, headers). The values of headers and body depends on the status:
      200 - OK                => Success. headers is a list of headers to return to the client. 
                                 The body is an ldp:Container resource in application/json format.
      others                  => headers may be an empty list or may include headers to return to the client.
                                 The body is a list of pairs, where the first element of the pair identifies the field in error, or is ''.
                                 The second element of the pair will start with a number, a space, and an optional string explaining the error.

    :param environ: a WSGI environment identifying the database to query
    :param query: the query to execute 
    :param complete_document_callback: (optional)A callback function that will be invoked for each resource in the query result
    """
    domain_logic = Domain_Logic(environ, complete_document_callback)
    #query = domain_logic.convert_compact_json_to_rdf_json(query)
    status, headers, result = domain_logic.execute_query(query)
    if status == 200:
        container_url = domain_logic.request_url()
        container_predicates = {
            RDF+'type': rdf_json.URI(LDP+'BasicContainer'),
            LDP+'contains': [rdf_json.URI(resource.default_subject()) for resource in result]
        }
        document = rdf_json.RDF_JSON_Document({container_url: container_predicates}, container_url)
        domain_logic.add_member_detail(document, result)
        body = domain_logic.convert_rdf_json_to_compact_json(document)
    else:
        body = json.dumps(result, cls=rdf_json.RDF_JSON_Encoder)
    return body, status, headers

def convert_to_requested_format(document, headers, environ): #TODO: pass in req, instead of environ ???
    """
    Convert the specified ``document`` to the format that best matches the Accept header of the specified ``environ``.
    The supported formats are:
        application/json (default)
        text/html
        application/rdf+json
        application/rdf+json+ce
        application/rdf+xml
        text/turtle
        application/x-turtle
        application/ld+json    
    """
    # In this application architectural style, the only method that ever returns HTML is GET. We never
    # return HTML from POST and we do not support application/x-www-form-urlencoded for POST
    domain_logic = Domain_Logic(environ)
    #TODO: if there is no accept header then use content-type header for post response ... is that what best_match does already?
    req = Request(environ)
    best_match = req.accept.best_match(['application/json', # default
                                        'text/html',
                                        'application/rdf+json',
                                        'application/rdf+json+ce',
                                        'application/rdf+xml',
                                        'text/turtle',
                                        'application/x-turtle',
                                        'application/ld+json'])
    if best_match == 'application/json':
        body = json.dumps(document)
    else:
        graph_url = document.get('_subject')
        document = domain_logic.convert_compact_json_to_rdf_json(document) #TODO: doesn't work for containers - ld_contains contents is not being converted
        if best_match == 'application/rdf+json+ce':
            body = json.dumps(document, cls=rdf_json.RDF_JSON_Encoder)
        elif best_match == 'application/rdf+json':
            document = rdf_json.normalize(document)
            body = json.dumps(document, cls=rdf_json.RDF_JSON_Encoder)
        elif best_match == 'application/rdf+xml' or best_match == 'text/turtle' or best_match == 'application/x-turtle' or best_match == 'application/ld+json':
            graph = rdfjson_to_graph(rdf_json.normalize(document))
            body = serialize_graph(graph, best_match, None) #TODO: should we use wfile instead of string return value?
        elif best_match == 'text/html':
            document = rdf_json.RDF_JSON_Document(document, graph_url)
            body = domain_logic.convert_rdf_json_to_html(document)
    if not header_set('Content-Type', headers):
        headers.append(('Content-Type', best_match))
    if not header_set('Cache-Control', headers):
        headers.append(('Cache-Control', 'no-cache'))
    headers.append(('Content-length', str(len(body))))
    return body, headers
        
def add_standard_headers(environ, headers):
    origin = environ.get('HTTP_ORIGIN')
    if origin and not header_set('Access-Control-Allow-Origin', headers):
        headers.append(('Access-Control-Allow-Origin', origin))
        headers.append(('Access-Control-Allow-Credentials', 'true'))
        headers.append(('Access-Control-Expose-Headers', 'Content-Location, Location'))
    if ('HTTP_AUTHORIZATION' in environ and environ['HTTP_AUTHORIZATION'].lower().startswith('bearer ')):
        # user credentials from another domain were passed by the client
        session_key = environ['HTTP_AUTHORIZATION'][len('bearer '):]
        add_cookie = True
        cookie = Cookie.SimpleCookie()
        if ('HTTP_COOKIE' in environ):
            cookie.load(environ['HTTP_COOKIE'])
            if 'SSSESSIONID' in cookie:
                add_cookie = False
    elif ('GUEST_AUTHORIZATION' in environ):
        #  a JWT for an anonymous user URL was generated for an unauthenticated request or the JWT claims expired
        session_key = environ['GUEST_AUTHORIZATION']
        add_cookie = True
    else:
        add_cookie = False
    if add_cookie:
        cookie = Cookie.SimpleCookie()
        cookie['SSSESSIONID'] = session_key # SSSESSIONID  is 'Site Server Session ID'
        cookie['SSSESSIONID']['path'] = '/'
        claims = jwt.decode(session_key, verify=False)
        cookie['user'] = claims['user']
        cookie['user']['path'] = '/'
        cookie_headers = map(lambda morsel: ('Set-Cookie', morsel.OutputString()), cookie.values())
        headers.extend(cookie_headers)

def header_set(header, headers):
    headerl = header.lower()
    for item in headers:
        if item[0].lower() == headerl:
            return True
    return False

class Domain_Logic(base.Domain_Logic):
    def __init__(self, environ, complete_document_callback=None, change_tracking=False):
        self.complete_document_callback = complete_document_callback
        super(Domain_Logic, self).__init__(environ, change_tracking)

    def create_document(self, document, document_id):
        # TODO: access control checking
        document = rdf_json.RDF_JSON_Document(document, '')
        self.complete_document_for_storage_insertion(document)
        self.preprocess_properties_for_storage_insertion(document)
        status, location, result = operation_primitives.create_document(self.user, document, self.request_hostname, self.tenant, self.namespace, document_id)
        if status == 201:
            if self.change_tracking:
                self.generate_change_event(base.CREATION_EVENT, location)
            # Todo: fix up self.document_id, self.path, self.path_parts to match location url of new document
            self.complete_result_document(result)
            return status, [('Location', str(location))], result
        else:
            return status, [], [('', result)]

    def execute_query(self, query):
        if not self.namespace:
            return self.bad_path()
        status, result = operation_primitives.execute_query(self.user, query, self.request_hostname, self.tenant, self.namespace)
        return status, [], result

    def complete_result_document(self, document):
        rdf_type = document.get_value(RDF+'type')
        if rdf_type and not str(rdf_type).startswith(LDP):
            if self.complete_document_callback is not None:
                temp_doc = self.convert_rdf_json_to_compact_json(document)
                self.complete_document_callback(temp_doc)
                #document.clear()
                document.update(self.convert_compact_json_to_rdf_json(temp_doc))
        return super(Domain_Logic, self).complete_result_document(document)
